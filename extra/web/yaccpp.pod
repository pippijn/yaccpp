=head1 YACC Preprocessor

The C<yaccpp> project is a preprocessor for YACC/Bison grammars.

=cut

L<Git repository|http://xinutec.org/git/lang/yaccpp.git/>

=pod

Yaccpp implements a few features on top of traditional YACC. As you will see
after reading this article, Yaccpp is more than just a preprocessor. Yaccpp is a
purely functional dynamically typed domain specific programming language for
describing context-free grammars. That is quite a mouthful, but this power does
not get in the way. Yaccpp is still about writing grammars, not programs.

=over

=item // Comments

Yacc allows /* */ comments. Yaccpp also allows C99-style // comments.

=item Merge multiple input files

By listing several files on the command line, you can merge multiple grammar
fragments into a single grammar. This aids in modularising grammars. You may
optionally define an entry point into the fragment with C<%start>. All
nonterminals in the fragment except the start symbol will be prefixed with the
start symbol name, thus creating a kind of scope.

=item Automatic parse tree generation

Yaccpp can generate parse tree classes for C++ or structs for C. These will
represent the original grammar structure rather than the expanded grammar.

=item Expand macro grammars

Yaccpp implements a variant of macro grammars as described in Peter Thiemann's
L<Macros for Context-Free Grammars|http://www.informatik.uni-freiburg.de/~thiemann/papers/macro-grammar.pdf>
paper.

=begin code CPP

   // E {sep E}*
   list.1(E, sep)
      : E
         { ($$ = new list)->add ($1); }
      | list.1(E, sep) sep E
         // You may refer to arguments of macros in action code using the ` prefix.
         { ($$ = $1)->add ($3, `sep); }
      ;

   statements: list.1 (statement, ';') ;

=end code CPP

In addition to the expansion described in the paper, Yaccpp supports higher
order programming by passing unexpanded macro names to other macros. These
macros can then expand the passed macro.

Macros can also be partially expanded by passing a strict subset of the required
arguments. This is a form of currying. Named arguments are also supported.
Macros can be overloaded by argument count. Using the C<...> operator at the end
of a parameter list, a macro may accept any number of arguments. Overloading
resolution will select L<variadic|http://en.wikipedia.org/wiki/Variadic_function>
macros only if there is no overload with the exact number of parameters.

=begin code CPP

   opt(E)
      : /* empty */
      | E
      ;

   // partially apply the macro
   apply(macro, arg): macro (arg) ;
   // recursively expand the apply macro with less and less arguments
   // until there is no "rest", anymore, and the first "apply" macro is called
   apply(macro, arg, rest...): apply (apply (macro, arg), rest...) ;

=end code CPP

Variadic arguments can not be directly expanded in the grammar. If you need a
space separated list of all arguments passed to a macro, you will need to use
something like this:

=begin code CPP

   expand(arg, rest...): arg expand(rest...);

=end code CPP

Yaccpp performs an extensive analysis of the macro grammar before attempting to
expand it, to ensure that the grammar terminates. It is also an error to have
unexpanded or partially expanded macros when the grammar terminates.


=item Regular grammars on the rhs

Yaccpp supports regular grammars known from regular expressions on the right
hand side of rules.

=begin code CPP

   identifier
      // Note that you need to write out the "..." yourself. Character ranges
      // are not supported.
      : ('a' | 'b' | ... 'z' | 'A' | ... | 'Z')
        ('a' | 'b' | ... 'z' | 'A' | ... | 'Z' | '0' | ... '9')*
      ;

   // Be careful:
   macro(A): A;
   // Since the argument is not an atom but rather a compound, it will
   // semantically be macro ((foo | bar)) and "A" in "macro" will be (foo | bar).
   // (foo | bar) is first expanded to an out-of-line rule, then passed to the
   // macro. The * then applies to the expanded macro call.
   nonterm: macro (foo | bar)*;

   // This would expand to the the following:
   nonterm: macro (anon123)*;
   nonterm: list.0 (macro (anon123));
   nonterm: list.0 (macro__anon123);
   nonterm: list.0__macro__anon123;

   not-a-macro: something;
   // Since not-a-macro does not accept any arguments, it is not called and
   // (foo | bar) is expanded in "nonterm".
   nonterm: not-a-macro (foo | bar);

=end code CPP

As a generic tool, Yaccpp cannot know how you want to handle lists and optional
elements, it requires the grammar to contain the following definitions:

=over

=item *

The C<*> postfix operator calls the C<list.0(E)> macro on the preceding atom.

=item +

The C<*> postfix operator calls the C<list.1(E)> macro on the preceding atom.

=item ?

The C<?> postfix operator calls the C<opt(E)> macro on the preceding atom.

=item |

The C<|> infix operator does not require any special support, because it is
actually just an anonymous rule. It is copied to a separate rule with a unique
name and that rule name is written in its place.

=back


=item Named references

Added in Bison 2.5, this feature is very useful for long rules. Especially when
these rules change a lot, it is easy to make a mistake in counting the indices.

=begin code CPP

   funcall: id '(' args ')'
         { $funcall = new funcall ($id, $args); }

   addition: exp[left] '+' exp[right-side]
         { $$ = $left + $[right-side]; } // use [] because the name has a - in it

=end code CPP

See the L<Bison manual|http://www.gnu.org/software/bison/manual/bison.html#Named-References>
for more examples and details.


=item Import token names and numbers from an enum

The C<%include-enum> directive can be used to parse a C enumeration in order to
extract token names and numbers. This is useful for unlinking the lexical
analysis from the parsing. The usual practice is to generate an C<enum> or
C<#define> list from the grammar and use that in the scanner. Using
C<%include-enum>, both use the same external token information source without
depending on each other.

=begin code CPP

   // we import symbols from "enum token_type" in "tokens.h":
   %include-enum "tokens.h" token_type

=end code CPP


=item Specify types on lhs of rules

Defining the types at the top of a grammar file splits information about rules
in two parts: the type information and the actual rule. In Yaccpp, you can
declare the type on the nonterminal you are defining.

=begin code CPP

   add_exp<add_exp_node>: exp + exp ;
   // becomes
   %type<add_exp_node> add_exp
   %%
   add_exp: exp + exp ;

=end code CPP

If you split the definition of a nonterminal into several separate rules, you
only need to define the type on one of them. Defining a different type on the
same nonterminal is an error.

=item Default token and rule types

Using the C<%default-token-type>, you can specify the type to be used on tokens
read from the included enum. They may be overridden using the C<%token> directive.
The C<%default-rule-type> defines the default type of lhs symbols.

=begin code CPP

   %default-rule-type <ast_node>
   %%
   decls: decl | decls decl ;

   // becomes:
   %type<ast_node> decls decl
   %%
   decls: decl | decls decl ;

=end code CPP

You may override the type analogously to the token types.


=item "typeof"

You may refer to the type of any typed nonterminal or terminal using the new
C<#> symbol.

=begin code CPP

   %type<funcall_node> funcall
   %%
   funcall: id '(' args ')'
         { $$ = new #$ ($1, $3); }

   // is translated to:
   funcall: id '(' args ')'
         { $$ = new funcall_node ($1, $3); }

=end code CPP

You may also refer to the types of rhs symbols, which may be useful in template
instantiations.

=begin code CPP

   %type<add_exp_node> add_exp
   %type<mul_exp_node> mul_exp
   %type<div_exp_node> div_exp
   %%
   add_exp: mul_exp + div_exp
         { $$ = new $#<#1, #3> ($1, $3); } // template instantiation

   // is translated to:
   add_exp: mul_exp + div_exp
         { $$ = new add_exp_node<add_exp_node, mul_exp_node> ($1, $3); }

=end code CPP

Referring to the type of untyped (non)terminals is an error.

=back

=item Extensible through Perl

If all the added functionality is not enough for you or you need something done
slightly differently, you can use the Perl API to influence the translation and
extract additional information from the grammar.
